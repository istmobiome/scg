---
title: "SCG analysis of Western Atlantic MAGs"
description: |
  Detailed workflow & data products
site: distill::distill_website
---

```{r setup, message=FALSE, results = 'hide', echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
set.seed(119)
#library(conflicted)
library(phyloseq); packageVersion("phyloseq")
library(Biostrings); packageVersion("Biostrings")
pacman::p_load(tidyverse, magrittr,
               codefolder, ggpubr, htmltools,
               reactable, downloadthis, captioner,
               install = FALSE, update = FALSE)
options(scipen=999)
knitr::opts_current$get(c(
  "cache",
  "cache.path",
  "cache.rebuild",
  "dependson",
  "autodep"
))
```

```{r, echo=FALSE, eval=TRUE}
xaringanExtra::use_panelset()
```

```{r, xaringanExtra-clipboard, echo=FALSE, eval=TRUE}
htmltools::tagList(
  xaringanExtra::use_clipboard(
    button_text = "<i class=\"fa fa-clone fa-2x\" style=\"color: #301e64\"></i>",
    success_text = "<i class=\"fa fa-check fa-2x\" style=\"color: #90BE6D\"></i>",
    error_text = "<i class=\"fa fa-times fa-2x\" style=\"color: #F94144\"></i>"
  ),
  rmarkdown::html_dependency_font_awesome()
)
```

```{r, message=FALSE, results = 'hide', eval=TRUE, echo=FALSE}
remove(list = ls())
load("page_build/index_mag.rdata")
```

```{r, message=FALSE, results = 'hide', eval=TRUE, echo=FALSE}
### COmmon formatting scripts
### NOTE: captioner.R must be read BEFORE captions_XYZ.R
source("assets/captioner/captioner.R")
source("assets/captioner/captions/captions.R")
source("assets/reactable/download_this_fun.R")
#source("assets/reactable/styles.R")
#source("assets/reactable/table_functions/dada2.R")
```

# MAG Workflow

In the first section of this workflow, we assess the taxonomy and coverage of SCG from our MAG collection. In the second part, we assess SCG across the entire metagenome. 

## Description of Data Products

The link below gives access to all data and data products generated in the workflow. This is a 7.5Mb zip file. 

```{r, eval=TRUE, echo=FALSE}
download_link(
  link = "https://github.com/istmobiome/scg/raw/main/files/MAG_WF_DATA.zip",
  button_label = "Download the full data pack here",
  button_type = "success",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```

> Note: the sub directiories **12_COVERAGE** and  **12_DETECTION** contain the final coverage/detection data for each MAG. See below for a description of all data products.

There are a number of data products generated in this workflow. Below is a description of each piece from this puzzle and links to download the data. Some of this information is redundant, others may not be useful, but all are included here for posterity. 

First, a description of individual tables. 

::: l-body-outset

| **file name**                                                                          | **description **                                            |
|----------------------------------------------------------------------------------------|-------------------------------------------------------------|
| [00_WA-MAGS.txt](files/MAG/00_WA-MAGS.txt)                                                   | list of all MAGs in the collection.                         |
| [01_hmm_hits_info.txt](files/MAG/01_hmm_hits_info.txt)                                 | HMM profiles in the contigs database                        |
| [02_Archaea_76.txt](files/MAG/02_Archaea_76.txt)                                       | description of Archaea_76 HMM profile.                      |
| [02_Bacteria_71.txt](files/MAG/02_Bacteria_71.txt)                                     | description of Bacteria_71 HMM profile.                     |
| [03_GTDB_Taxonomy.txt](files/MAG/03_GTDB_Taxonomy.txt)                                 | list of GTDB taxonomy genes.                                |
| [04_SCG_master_list.txt](files/MAG/04_SCG_master_list.txt)                             | master list of all SCG used in this analysis.               |
| [05_MAG-COMPLETENESS.txt](files/MAG/05_MAG-COMPLETENESS.txt)                           | completion & genome statistics for each MAG.                |
| [05_MAG-TAXONOMY.txt](files/MAG/05_MAG-TAXONOMY.txt)                                   | GTDB taxonomy  for each MAG.                                |
| [05_MAG-TAXONOMY-PER-GENOME-SCG.txt](files/MAG/05_MAG-TAXONOMY-PER-GENOME-SCG.txt)     | GTDB taxonomy for each gene in a MAG.                       |
| [06_MAG_TAXONOMY_and_COMPLETENESS.txt](files/MAG/06_MAG_TAXONOMY_and_COMPLETENESS.txt) | combined completion & taxonomy estimates.                   |
| [07_Archaea_76-across-MAGs.txt](files/MAG/07_Archaea_76-across-MAGs.txt)               | distribution of Archaea_76 SCG across MAGs.                 |
| [07_Bacteria_71-across-MAGs.txt](files/MAG/07_Bacteria_71-across-MAGs.txt)             | distribution of Bacteria_71 SCG across MAGs.                |
| [08_MAGS-Archaea_76-sequences.fa](files/MAG/08_MAGS-Archaea_76-sequences.fa)           | fasta file of Archaea_76 SCG hits across MAGs.              |
| [08_MAGS-Bacteria_71-sequences.fa](files/MAG/08_MAGS-Bacteria_71-sequences.fa)         | fasta file of Bacteria_71 SCG hits across MAGs.             |
| [09_MAGS-Archaea_76-details.txt](files/MAG/09_MAGS-Archaea_76-details.txt)             | parsed SCG details from Archaea_76 fasta file.              |
| [09_MAGS-Bacteria_71-details.txt](files/MAG/09_MAGS-Bacteria_71-details.txt)           | parsed SCG details from Bacteria_71 fasta file.             |
| [internal-genomes.txt](files/MAG/internal-genomes.txt)                                 | paths to CONTIGS.db & PROFILE.db for each MAG.              |
:::


::: l-body-outset

Now a description of the data from the main results of the analysis. Each main directory is named by the HMM profile (`Archaea_76/` or `Bacteria_71/`) and both contain the following sub directories: 

| **subdirectory**           | **description **                                                          |
|----------------------------|---------------------------------------------------------------------------|
| 09_HMM_HITS_PER_GENE_CALLS | details of SCG present in each MAG                                        |
| 10_GENE_CALLER_IDS         | list of SCG IDs for each MAG                                              |
| 11_COVERAGE_RAW            | raw output of coverage data from `anvi-script-get-hmm-hits-per-gene-call` |
| 11_DETECTION_RAW           | raw output of detection data from `anvi-script-get-hmm-hits-per-gene-call`|
| **12_COVERAGE**            | **final output of coverage data for each MAG**                            |
| **12_DETECTION**           | **final output of detection data for each MAG**                           |

:::

## Generate SCG lists

The first step is to determine which HMM profiles are present in the `contigs.db`. There are a few different ways to accomplish this task. Here we run the following command:

```bash
anvi-export-table 03_CONTIGS/WA-contigs.db --table hmm_hits_info \
                  --output-file 01_hmm_hits_info.txt
```

This command produces a file that contains information about each HMM profile in the `contigs.db`. Here I modified the output table a bit to include links to the databases. 

```{r, eval=TRUE, echo=FALSE}
hmm_hits_info <- read_delim("files/MAG/01_hmm_hits_info.txt", delim = "\t")
```

<small>`r caption_tab("hmm_hits_info")`</small>

```{r, eval=TRUE, layout="l-page", echo=FALSE}
seq_table <- hmm_hits_info
reactable(seq_table,
  defaultColDef = colDef(
    header = function(value) gsub("_", " ", value, fixed = TRUE),
    cell = function(value) format(value, nsmall = 1),
    align = "left", filterable = FALSE, sortable = TRUE, resizable = TRUE,
    footerStyle = list(fontWeight = "bold")
    ), 
  columns = list(
    source = colDef(name = "Source", 
                       sticky = "left", 
                       style = list(borderRight = "1px solid #eee"),
                       headerStyle = list(borderRight = "1px solid #eee"), 
                       align = "left",
                       minWidth = 200), 
    doi = colDef(show = FALSE, cell = function(value) {
      htmltools::tags$a(href = value, target = "_blank", value)
    }
    ),
    #doi = colDef(sticky = "left"),
    reference = colDef(html = TRUE, cell = function(value, index) {
      sprintf('<a href="%s" target="_blank">%s</a>', seq_table$doi[index], value)
    }, minWidth = 150),
    db_link = colDef(cell = function(value) {
      htmltools::tags$a(href = value, target = "_blank", value)
    }, minWidth = 200),
    search_type = colDef(sticky = "left", minWidth = 200),
    domain = colDef(sticky = "left", minWidth = 90),
    genes = colDef(sticky = "left", minWidth = 2000)
    ), 
  searchable = FALSE, defaultPageSize = 10, 
  pageSizeOptions = c(5, 10, nrow(seq_table)), 
  showPageSizeOptions = FALSE, highlight = TRUE, 
  bordered = TRUE, striped = TRUE, compact = FALSE, 
  wrap = FALSE, showSortable = FALSE, fullWidth = TRUE,
  theme = reactableTheme(style = list(fontSize = "0.8em")))
rm(seq_table)
```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack file** [00_WA-MAGS.txt](files/MAG/00_WA-MAGS.txt) 
::::

For this analysis we are mainly interested in the `Archaea_76` and `Bacteria_71` profiles. Here we need to parse the `genes` column for both sources and create a master list of target single copy genes (SCG) for each. 

```{r, code_folding=TRUE, eval=FALSE}
# Archaea_76
tmp_tbl <- hmm_hits_info[1, c(1,7)]
tmp_tbl <- tidyr::separate_rows(tmp_tbl, "genes", sep = ", ", convert = TRUE)
tmp_tbl[1] <- NULL 
arch_tbl <- tmp_tbl 
# Bacteria_71
tmp_tbl <- hmm_hits_info[2, c(1,7)]
tmp_tbl <- tidyr::separate_rows(tmp_tbl, "genes", sep = ", ", convert = TRUE)
tmp_tbl[1] <- NULL 
bact_tbl <- tmp_tbl 
rm(tmp_tbl)
```

It would also be nice to include the [Pfam](https://pfam.xfam.org/) ID and database links for each SCG. We can get this information from the anvi'o database links provided in the table above.

```{r, code_folding = TRUE, eval=FALSE}
tmp_file <- 'https://raw.githubusercontent.com/meren/anvio/master/anvio/data/hmm/Archaea_76/genes.txt'
download.file(tmp_file, destfile = "files/MAG/02_Archaea_76.txt")
rm(tmp_file)
tmp_file <- 'https://raw.githubusercontent.com/meren/anvio/master/anvio/data/hmm/Bacteria_71/genes.txt'
download.file(tmp_file, destfile = "files/MAG/02_Bacteria_71.txt")
rm(tmp_file)
```

Then we add the prefix `https://pfam.xfam.org/family/` to each accession number to generate a hyperlink to the Pfam database. 

```{r, eval=FALSE, code_folding=TRUE}
# Archaea_76
tmp_tbl <- read_delim("files/MAG/02_Archaea_76.txt", delim = "\t")
tmp_tbl$hmmsource <- NULL
tmp_tbl$pfam_link <- tmp_tbl$accession
tmp_tbl$pfam_link = paste0('https://pfam.xfam.org/family/', tmp_tbl$pfam_link)
arch_tbl <- dplyr::full_join(arch_tbl, tmp_tbl, by = c("genes" = "gene"))
rm(tmp_tbl)

# Bacteria_71
tmp_tbl <- read_delim("files/MAG/02_Bacteria_71.txt", delim = "\t")
tmp_tbl$hmmsource <- NULL
tmp_tbl$pfam_link <- tmp_tbl$accession
tmp_tbl$pfam_link = paste0('https://pfam.xfam.org/family/', tmp_tbl$pfam_link)
bact_tbl <- dplyr::full_join(bact_tbl, tmp_tbl, by = c("genes" = "gene"))
rm(tmp_tbl)

system("rm files/MAG/02_Archaea_76.txt")
system("rm files/MAG/02_Bacteria_71.txt")
```

And then save the tables for each profile. 

```{r, eval=FALSE, code_folding=TRUE}
write.table(arch_tbl, "files/MAG/02_Archaea_76.txt", col.names  = TRUE, 
            row.names = FALSE, sep = "\t", quote = FALSE)
write.table(bact_tbl, "files/MAG/02_Bacteria_71.txt", col.names  = TRUE, 
            row.names = FALSE, sep = "\t", quote = FALSE)
```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack files**   
- [02_Archaea_76.txt](files/MAG/02_Archaea_76.txt)  
- [02_Bacteria_71.txt](files/MAG/02_Bacteria_71.txt)  
::::

Sweet. 

Now, we need to grab the list of all single copy genes from the [Genome Taxonomy Database](https://gtdb.ecogenomic.org/) we used in assigning taxonomy to our collection of MAGs. One way to do this is to list the files in the `GTDB/SCG_SEARCH_DATABASES` directory within anvi'o. For that, a simple bash one-liner will do the trick. Alternatively, you can assess the same information on the [anvi'o GitHub site](https://github.com/meren/anvio/tree/master/anvio/data/misc/SCG_TAXONOMY/GTDB/SCG_SEARCH_DATABASES).

```{bash}
ls -1 PATH_TO_SCG_SEARCH_DATABASES | sed 's/.gz//'
```

```{r, echo=FALSE, eval=TRUE}
system("ls -1 /Users/scottjj/github/anvio/anvio/data/misc/SCG_TAXONOMY/GTDB/SCG_SEARCH_DATABASES | sed 's/.gz//'", 
                   intern = TRUE)
```

```{r, echo=FALSE, eval=FALSE}
tmp_gtdb <- system("ls -1 /Users/scottjj/github/anvio/anvio/data/misc/SCG_TAXONOMY/GTDB/SCG_SEARCH_DATABASES | sed 's/.gz//'", 
                   intern = TRUE)
gtdb <- data.frame(tmp_gtdb)
gtdb <- gtdb %>% dplyr::rename("genes" = 1)
write.table(gtdb, "files/MAG/03_GTDB_Taxonomy.txt", col.names  = TRUE, 
            row.names = FALSE, sep = "\t", quote = FALSE)
rm(tmp_gtdb)
```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack file** [03_GTDB_Taxonomy.txt](files/MAG/03_GTDB_Taxonomy.txt) 
::::

Now we create a master look up table containing all SCG from `Archaea_76` and `Bacteria_71`, then indicate which SCGs are also used in the GTDB_Taxonomy. 

```{r, code_folding=TRUE, eval=FALSE}
arch_tbl$Archaea_76 <- "yes"
bact_tbl$Bacteria_71 <- "yes"
tmp_scg <- dplyr::full_join(arch_tbl, bact_tbl, by = c("genes", "accession", "pfam_link"), keep = FALSE)
gtdb$GTDB_Taxonomy <- "yes"

tmp_scg <- dplyr::full_join(tmp_scg, gtdb, by = c("genes" = "genes"), keep = FALSE)
scg_table <- tmp_scg
write.table(scg_table, "files/MAG/04_SCG_master_list.txt", col.names  = TRUE, 
            row.names = FALSE, sep = "\t", quote = FALSE)
rm(tmp_scg)
```

<small>`r caption_tab("SCG_master_list")`</small>

```{r, eval=TRUE, layout="l-body-outset", echo=FALSE}
seq_table <- scg_table
reactable(seq_table,
  defaultColDef = colDef(
    header = function(value) gsub("_", " ", value, fixed = TRUE),
    cell = function(value) format(value, nsmall = 1),
    align = "left", filterable = TRUE, sortable = TRUE, resizable = TRUE,
    footerStyle = list(fontWeight = "bold")
    ), 
  columns = list(
    genes = colDef(name = "genes", 
                       sticky = "left", 
                       style = list(borderRight = "1px solid #eee"),
                       headerStyle = list(borderRight = "1px solid #eee"), 
                       align = "left",
                       minWidth = 100), 
    pfam_link = colDef(show = FALSE, cell = function(value) {
      htmltools::tags$a(href = value, target = "_blank", value)
    }
    ),
    accession = colDef(html = TRUE, cell = function(value, index) {
      sprintf('<a href="%s" target="_blank">%s</a>', seq_table$pfam_link[index], value)
    }, minWidth = 100)#,
    ), 
  searchable = TRUE, defaultPageSize = 5, 
  pageSizeOptions = c(5, 10, nrow(seq_table)), 
  showPageSizeOptions = TRUE, highlight = TRUE, 
  bordered = TRUE, striped = TRUE, compact = FALSE, 
  wrap = FALSE, showSortable = TRUE, fullWidth = TRUE,
  theme = reactableTheme(style = list(fontSize = "0.8em")))
rm(seq_table)
```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack file** [04_SCG_master_list.txt](files/MAG/04_SCG_master_list.txt)
::::

> It is important to note that `Archaea_76` and `Bacteria_71` share **`r nrow(scg_table %>% filter(!is.na(Archaea_76), !is.na(Bacteria_71)) )`** SCGs, `r nrow(scg_table %>% filter(!is.na(Archaea_76), !is.na(Bacteria_71),  !is.na(GTDB_Taxonomy)))` of which are GTDB taxonomy genes. 

## MAG Completeness & Taxonomy 

Now we can generate some stats about our MAG collection. We define a MAG as:

- Greater than 70% completion AND less than 10% redundancy 

OR

- Larger than 1Mb genome size AND less than 10% redundancy 

What this means is that even if a bin has < 70% completion, we call it a MAG as long as it is > 1Mb in size. MAGs are denoted by the prefix `WA_MAG`. We also included 9 bins in this collection that had 10 or more total GTDB SCGs, despite not meeting either of the criteria described above. These are denoted by the prefix `WA_Bin`.  

First we estimate genome completeness.

```bash
anvi-estimate-genome-completeness --contigs-db 03_CONTIGS/WA-contigs.db \
                                  --profile-db 06_MERGED/WA/PROFILE.db \
                                  --collection-name DASTOOL_MAGS \
                                  --output-file 05_MAG-COMPLETENESS.txt
```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack file** [05_MAG-COMPLETENESS.txt](files/MAG/05_MAG-COMPLETENESS.txt)
::::

Then let's estimate MAG consensus taxonomy using `anvi-estimate-scg-taxonomy`. Here we add the flag `--compute-scg-coverages` to calculate coverage statistics of single-copy core genes for which we have taxonomic information. **Note this is not the same as computing coverage statistics for the entire MAG**, which we will do later in the workflow. 

```bash
anvi-estimate-scg-taxonomy --profile-db 06_MERGED/WA/PROFILE.db \
                           --contigs-db 03_CONTIGS/WA-contigs.db  \
                           --output-file 05_MAG-TAXONOMY.txt  \
                           --compute-scg-coverages  \
                           --collection-name DASTOOL_MAGS \
```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack file** [05_MAG-TAXONOMY.txt](files/MAG/05_MAG-TAXONOMY.txt)
::::

We can also rerun the command using the flag `--per-scg-output-file`, which provides taxonomic information and percent identity scores for each SCG in a MAG. So rather than a consensus taxonomy for each MAG, we get info for each SCG hit in a MAG. 

```bash
anvi-estimate-scg-taxonomy --profile-db 06_MERGED/WA/PROFILE.db \
                           --contigs-db 03_CONTIGS/WA-contigs.db  \
                           --collection-name DASTOOL_MAGS \
                           --per-scg-output-file 05_MAG-TAXONOMY-PER-GENOME-SCG.txt
```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack file** [05_MAG-TAXONOMY-PER-GENOME-SCG.txt](files/MAG/05_MAG-TAXONOMY-PER-GENOME-SCG.txt)
::::

OK, now we can merge the MAG completeness and the MAG taxonomy tables and view the data. We will omit the coverage statistics for now so we can focus on the MAG details.  

```{r, eval=TRUE, echo=FALSE}
mag_tax <- read_delim("files/MAG/05_MAG-TAXONOMY.txt", delim = "\t")
mag_comp <- read_delim("files/MAG/05_MAG-COMPLETENESS.txt", delim = "\t")
mag_summary <- dplyr::full_join(mag_comp, mag_tax, by = c("bin name" = "bin_name"))
write.table(mag_summary, "files/MAG/06_MAG_TAXONOMY_and_COMPLETENESS.txt", col.names  = TRUE, 
            row.names = FALSE, sep = "\t", quote = FALSE)
tmp_mag <- mag_summary
tmp_mag <- tmp_mag %>% dplyr::select(-contains(c("WAM_", "WAR_")))
```

<small>`r caption_tab("MAG_TAXONOMY_and_COMPLETENESS")`</small>

```{r, eval=TRUE, layout="l-page", echo=FALSE}
seq_table <- tmp_mag
reactable(seq_table,
  defaultColDef = colDef(
    header = function(value) gsub("_", " ", value, fixed = TRUE),
    #cell = function(value) format(value, nsmall = 0),
    align = "left", filterable = TRUE, sortable = TRUE, resizable = TRUE,
    footerStyle = list(fontWeight = "bold")
    ), 
  columns = list(
    `bin name` = colDef(name = "MAG ID", 
                       sticky = "left", 
                       style = list(borderRight = "5px solid #eee"),
                       headerStyle = list(borderRight = "5px solid #eee"), 
                       align = "left",
                       minWidth = 150), 
    `confidence` = colDef(filterable = FALSE),
    `% completion` = colDef(filterable = FALSE),
    `% redundancy` = colDef(filterable = FALSE),
    `num_splits` = colDef(filterable = FALSE),
    `total length` = colDef(name = "total length", filterable = FALSE, 
                       style = list(borderRight = "5px solid #eee"),
                       headerStyle = list(borderRight = "5px solid #eee"))),
  columnGroups = list(
    colGroup(name = "Completeness", columns = c("domain", "confidence", 
                                                "% completion", "% redundancy", 
                                                "num_splits", "total length"),
                       headerStyle = list(fontSize = "1em", borderRight = "5px solid #eee")),
    colGroup(name = "SCG Taxonomy", columns = c("total_scgs", "supporting_scgs", 
                                                "t_domain", "t_phylum", "t_class", 
                                                "t_order", "t_family", "t_genus", "t_species"),
                       headerStyle = list(fontSize = "1em"))
  ),
  searchable = TRUE, defaultPageSize = 5, 
  pageSizeOptions = c(5, 10, nrow(seq_table)), 
  showPageSizeOptions = TRUE, highlight = TRUE, 
  bordered = TRUE, striped = TRUE, compact = FALSE, 
  wrap = FALSE, showSortable = TRUE, fullWidth = TRUE,
  theme = reactableTheme(style = list(fontSize = "0.8em")))
rm(seq_table)
rm(tmp_mag)
```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack file** [06_MAG_TAXONOMY_and_COMPLETENESS.txt](files/MAG/06_MAG_TAXONOMY_and_COMPLETENESS.txt)
::::

Ok, let's review. 

In total, our collection has `r nrow(mag_summary)` MAGs. According to `anvi-estimate-genome-completeness` there were `r length(which(mag_summary$domain == "BACTERIA"))` Bacteria MAGs, `r length(which(mag_summary$domain == "ARCHAEA"))` Archaea MAGs, and `r length(which(mag_summary$domain == "EUKARYA"))` Eukarya MAG. 

The values were a little bit lower according to `anvi-estimate-scg-taxonomy`, specifically `r length(which(mag_summary$t_domain == "Bacteria"))` Bacteria MAGs, `r length(which(mag_summary$t_domain == "Archaea"))` Archaea MAGs, and no Eukarya MAGs.

So why the difference? Well first of all the GTDB does not contain Eukaryotes. Next, take a look at the `total scgs` column from the `anvi-estimate-scg-taxonomy` output (see table above) and notice that `r length(which(mag_summary$total_scgs == 0))` MAGs have the value 0. This indicates that of the `r nrow(gtdb)` SCG used for taxonomic assignment, these MAGs have no hits. 

```{r, echo=FALSE, eval=TRUE}
tot_mag <- length(which(mag_summary$`% completion` >= 70 & mag_summary$`% redundancy` <= 10))
```

What else? Well, there are `r tot_mag` MAGs that have completion values > 70% and redundancy values < 10% and `r length(which(mag_summary$total_scgs >= 10))` that have at least 10 total SCG used in taxonomic classification. 

> The last thing to check is whether the domain classification is the same for `anvi-estimate-genome-completeness` and  `anvi-estimate-scg-taxonomy` (where applicable). 

Well we know there are `r nrow(mag_summary)` MAGs total, `r length(which(mag_summary$t_domain == "None"))` of which have no GTDB classification. So, there should be `r nrow(mag_summary) - length(which(mag_summary$t_domain == "None"))` MAGs that have identical domain classification. Let's see (and hope so).

```{r, eval=TRUE}
tmp_tbl <- mag_summary
tmp_tbl$t_domain <- toupper(tmp_tbl$t_domain)
sum(tmp_tbl$domain == tmp_tbl$t_domain)
```

Booya. 

## SCG Hits across MAGs

Next we can look at the distribution of SCGs from the `Bacteria_71` and `Archaea_76` HMM profiles across the MAGs. For this we first need to generate individual `PROFILE.db`s and `CONTIG.db`s for each MAG in our curate MAG collection. Luckily, anvi'o has us covered. 

```bash
anvi-split --pan-or-profile-db 06_MERGED/WA/PROFILE.db \
           --contigs-db 03_CONTIGS/WA-contigs.db  \
           --collection-name DASTOOL_MAGS  \
           --output-dir 10_SPLITS/WA/
```

As part of this program, anvi'o will add a collection called `DEFAULT` and a single bin called `ALL_SPLITS`. This will become important in the next step when we generate an `internal-genomes` file. 

The program we will use to look at the distribution of SCGs across MAGs is `anvi-script-gen-hmm-hits-matrix-across-genomes`. The program needs either an `external-genomes` file or an `internal-genomes` file so it knows where to find the genomes of interest for the analysis. We will use the `internal-genomes` file, which is a five-column TAB-delimited flat text file. 

The header line must contain these columns: **'name', 'bin_id', 'collection_id', 'profile_db_path', 'contigs_db_path'**. Each line lists a single MAG. As far as I know the `external-genomes` option also works perfectly fine. 

So we generate this file and run the command against both HMM profiles. 

```bash
anvi-script-gen-hmm-hits-matrix-across-genomes \
                 --internal-genomes internal-genomes.txt \
                 --hmm-source Archaea_76 \
                 --output-file 07_Archaea_76-across-MAGs.txt

anvi-script-gen-hmm-hits-matrix-across-genomes \
                 --internal-genomes internal-genomes.txt \
                 --hmm-source Bacteria_71 \
                 --output-file 07_Bacteria_71-across-MAGs.txt
```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack files**   
- [07_Archaea_76-across-MAGs.txt](files/MAG/07_Archaea_76-across-MAGs.txt)  
- [07_Bacteria_71-across-MAGs.txt](files/MAG/07_Bacteria_71-across-MAGs.txt)
::::

Sweet, now for both HMM profiles, we can look at **a**) the number of MAGs represented by each SCG and **b**) the number of unique SCG present in each MAG. Of course keep in mind that we ran both HMM profiles across all MAGs, *regardless of their domain classification*. So what this means for example is that we expect an Archaea MAG to have fewer hits when run against `Bacteria_71` than against `Archaea_76`. 

```{r, eval=TRUE, echo=FALSE}
####### ####### ####### ####### 
## Bacteria_71
####### ####### ####### ####### 
bact71 <- read_delim("files/MAG/07_Bacteria_71-across-MAGs.txt", delim = "\t")
t_bact71 <- data.table::transpose(bact71, keep.names = "SCG", make.names = "genome_or_bin")

## Sum number of MAGs represented by each SCG
tmp_sum <- data.frame(sapply(bact71, function(x) sum(x > 0)))
tmp_sum <- tmp_sum %>% tibble::rownames_to_column("SCG")
tmp_sum <- tmp_sum[-1,]

tmp_tbl <- dplyr::full_join(tmp_sum, t_bact71, by = c("SCG" = "SCG"))
tmp_tbl <- tmp_tbl %>% dplyr::rename("total_mags" = 2)

bact71_by_scg <- tmp_tbl
rm(tmp_sum, tmp_tbl)

## Sum number of unique SCG present in each MAG

tmp_tbl <- mag_summary
tmp_tbl[, c(3:ncol(tmp_tbl))] <- NULL
tmp_tbl <- dplyr::full_join(tmp_tbl, bact71, by = c("bin name" = "genome_or_bin"))
tmp_sum <- data.frame(sapply(t_bact71, function(x) sum(x > 0)))
tmp_sum <- tmp_sum %>% tibble::rownames_to_column("MAG")
tmp_sum <- tmp_sum[-1,]
tmp_sum <- tmp_sum %>% dplyr::rename("unique_scgs" = 2)

tmp_tbl <- dplyr::full_join(tmp_tbl, tmp_sum , by = c("bin name" = "MAG"))
tmp_tbl <- tmp_tbl %>% dplyr::relocate("unique_scgs", .after = "domain")
bact71_by_mag <- tmp_tbl
rm(tmp_sum)
rm(tmp_tbl)

####### ####### ####### ####### 
## Archaea_76
####### ####### ####### ####### 
arch76 <- read_delim("files/MAG/07_Archaea_76-across-MAGs.txt", delim = "\t")
t_arch76 <- data.table::transpose(arch76, keep.names = "SCG", make.names = "genome_or_bin")

## Sum number of MAGs represented by each SCG
tmp_sum <- data.frame(sapply(arch76, function(x) sum(x > 0)))
tmp_sum <- tmp_sum %>% tibble::rownames_to_column("SCG")
tmp_sum <- tmp_sum[-1,]

tmp_tbl <- dplyr::full_join(tmp_sum, t_arch76, by = c("SCG" = "SCG"))
tmp_tbl <- tmp_tbl %>% dplyr::rename("total_mags" = 2)

arch76_by_scg <- tmp_tbl
rm(tmp_sum, tmp_tbl)

## Sum number of unique SCG present in each MAG

tmp_tbl <- mag_summary
tmp_tbl[, c(3:ncol(tmp_tbl))] <- NULL
tmp_tbl <- dplyr::full_join(tmp_tbl, arch76, by = c("bin name" = "genome_or_bin"))
tmp_sum <- data.frame(sapply(t_arch76, function(x) sum(x > 0)))
tmp_sum <- tmp_sum %>% tibble::rownames_to_column("MAG")
tmp_sum <- tmp_sum[-1,]
tmp_sum <- tmp_sum %>% dplyr::rename("unique_scgs" = 2)

tmp_tbl <- dplyr::full_join(tmp_tbl, tmp_sum , by = c("bin name" = "MAG"))
tmp_tbl <- tmp_tbl %>% dplyr::relocate("unique_scgs", .after = "domain")
arch76_by_mag <- tmp_tbl
rm(tmp_sum)
rm(tmp_tbl)
```

</br>

###  Summary of Bacteria 71 SCG

::: l-body
::: {.panelset}
::: {.panel}

#### By SCG

<small>`r caption_tab("bacteria_71_by_scg")`</small>

```{r, eval=TRUE, layout="l-body", echo=FALSE}
seq_table <- bact71_by_scg[, 1:2]
reactable(seq_table,
  defaultColDef = colDef(
    header = function(value) gsub("_", " ", value, fixed = TRUE),
    cell = function(value) format(value, nsmall = 0),
    align = "left", filterable = FALSE, sortable = TRUE, resizable = TRUE,
    footerStyle = list(fontWeight = "bold")
    ), 
  columns = list(
    SCG = colDef(name = "SCG", 
                       sticky = "left", 
                       style = list(borderRight = "1px solid #eee"),
                       headerStyle = list(borderRight = "1px solid #eee"), 
                       align = "left",
                       minWidth = 100, filterable = TRUE)
    ), 
  searchable = FALSE, defaultPageSize = 5, 
  pageSizeOptions = c(5, 10, nrow(seq_table)), 
  showPageSizeOptions = TRUE, highlight = TRUE, 
  bordered = TRUE, striped = TRUE, compact = FALSE, 
  wrap = FALSE, showSortable = FALSE, fullWidth = TRUE,
  theme = reactableTheme(style = list(fontSize = "0.8em")))
rm(seq_table)
```
:::

::: {.panel}

#### By MAG

<small>`r caption_tab("bacteria_71_by_mag")`</small>


```{r, eval=TRUE, layout="l-body", echo=FALSE}
seq_table <- bact71_by_mag[, 1:3]
#seq_table <- dplyr::filter(seq_table, domain == "BACTERIA")
reactable(seq_table,
  defaultColDef = colDef(
    header = function(value) gsub("_", " ", value, fixed = TRUE),
    cell = function(value) format(value, nsmall = 0),
    align = "left", filterable = FALSE, sortable = TRUE, resizable = TRUE,
    footerStyle = list(fontWeight = "bold")
    ), 
  columns = list(
    `bin name` = colDef(name = "MAG", 
                       sticky = "left", 
                       style = list(borderRight = "1px solid #eee"),
                       headerStyle = list(borderRight = "1px solid #eee"), 
                       align = "left",
                       minWidth = 100, filterable = TRUE),
    domain = colDef(filterable = TRUE)
    ), 
  searchable = FALSE, defaultPageSize = 5, 
  pageSizeOptions = c(5, 10, nrow(seq_table)), 
  showPageSizeOptions = TRUE, highlight = TRUE, 
  bordered = TRUE, striped = TRUE, compact = FALSE, 
  wrap = FALSE, showSortable = FALSE, fullWidth = TRUE,
  theme = reactableTheme(style = list(fontSize = "0.8em")))
rm(seq_table)
```
:::
:::
:::

### Summary of Archaea 76 SCGs

::: l-body
::: {.panelset}
::: {.panel}

#### By SCG 

<small>`r caption_tab("archaea_76_by_scg")`</small>

```{r, eval=TRUE, layout="l-body", echo=FALSE}
seq_table <- arch76_by_scg[, 1:2]
reactable(seq_table,
  defaultColDef = colDef(
    header = function(value) gsub("_", " ", value, fixed = TRUE),
    cell = function(value) format(value, nsmall = 0),
    align = "left", filterable = FALSE, sortable = TRUE, resizable = TRUE,
    footerStyle = list(fontWeight = "bold")
    ), 
  columns = list(
    SCG = colDef(name = "SCG", 
                       sticky = "left", 
                       style = list(borderRight = "1px solid #eee"),
                       headerStyle = list(borderRight = "1px solid #eee"), 
                       align = "left",
                       minWidth = 100, filterable = TRUE)
    ), 
  searchable = FALSE, defaultPageSize = 5, 
  pageSizeOptions = c(5, 10, nrow(seq_table)), 
  showPageSizeOptions = TRUE, highlight = TRUE, 
  bordered = TRUE, striped = TRUE, compact = FALSE, 
  wrap = FALSE, showSortable = FALSE, fullWidth = TRUE,
  theme = reactableTheme(style = list(fontSize = "0.8em")))
rm(seq_table)
```

:::

::: {.panel}

#### By MAG 

<small>`r caption_tab("archaea_76_by_scg")`</small>


```{r, eval=TRUE, layout="l-body", echo=FALSE}
seq_table <- arch76_by_mag[, 1:3]
#seq_table <- dplyr::filter(seq_table, domain == "ARCHAEA")
reactable(seq_table,
  defaultColDef = colDef(
    header = function(value) gsub("_", " ", value, fixed = TRUE),
    cell = function(value) format(value, nsmall = 0),
    align = "left", filterable = FALSE, sortable = TRUE, resizable = TRUE,
    footerStyle = list(fontWeight = "bold")
    ), 
  columns = list(
    `bin name` = colDef(name = "MAG", 
                       sticky = "left", 
                       style = list(borderRight = "1px solid #eee"),
                       headerStyle = list(borderRight = "1px solid #eee"), 
                       align = "left",
                       minWidth = 100, filterable = TRUE),
    domain = colDef(filterable = TRUE)
    ), 
  searchable = FALSE, defaultPageSize = 5, 
  pageSizeOptions = c(5, 10, nrow(seq_table)), 
  showPageSizeOptions = TRUE, highlight = TRUE, 
  bordered = TRUE, striped = TRUE, compact = FALSE, 
  wrap = FALSE, showSortable = FALSE, fullWidth = TRUE,
  theme = reactableTheme(style = list(fontSize = "0.8em")))
rm(seq_table)
```
:::
:::
:::

## SCG Coverage across MAGs

In the section above we used `anvi-split` to generate `PROFILE.db`s and `CONTIG.db`s for each MAG. We will now query these databases to access gene hits to the Archaea_76 and Bacteria_71 HMM profiles. 

```bash
for mag in `cat 00_WA-MAGS.txt`
do anvi-script-get-hmm-hits-per-gene-call \
                       --contigs-db 10_SPLITS/WA/$mag/CONTIGS.db \
                       --hmm-source Archaea_76 \
                       --output-file Archaea_76/09_HMM_HITS_PER_GENE_CALLS/$mag-Archaea_76.txt

do anvi-script-get-hmm-hits-per-gene-call \
                       --contigs-db 10_SPLITS/WA/$mag/CONTIGS.db \
                       --hmm-source Bacteria_71 \
                       --output-file Bacteria_71/09_HMM_HITS_PER_GENE_CALLS/$mag-Bacteria_71.txt
done
```

These commands will each generate a 5-column text file for every MAG containing the following information:

- `unique_entry_id` I honestly don't know what this is but we do not need this info here (FIX). 

- `gene_callers_id` The unique gene caller ID recognized by anvi’o.

- `source` The name of the functional annotation source, in other words the database that the function came from. In this case, either Arachea_76 or Bacteria_71.

- `gene_name` The name of the SCG. 

- `gene_hmm_id` The Pfam gene ID.

```{r, eval=TRUE}
tmp_hits <- read_delim("files/MAG/Bacteria_71/09_HMM_HITS_PER_GENE_CALLS/WA_MAG_00001-Bacteria_71.txt", delim = "\t")
head(tmp_hits)
```

What we need to do is parse out the `gene_callers_id` column and remove the header. A simple `bash` one-liner should do the trick. We will use the file `00_WA-MAGS.txt`--which is a single column file containing the names of each MAG--to loop through each output file and generate gene ID files. 

```bash
for mag in `cat 00_WA-MAGS.txt`

do awk '{print $2}' files/MAG/Archaea_76/09_HMM_HITS_PER_GENE_CALLS/$mag-Archaea_76.txt | sed 1d > Archaea_76/10_GENE_CALLER_IDS/$mag-Archaea_76-gene_ids.txt

do awk '{print $2}' files/MAG/Bacteria_71/09_HMM_HITS_PER_GENE_CALLS/$mag-Bacteria_71.txt | sed 1d > Bacteria_71/10_GENE_CALLER_IDS/$mag-Bacteria_71-gene_ids.txt

done
```

Excellent. Then we use the `-gene_ids.txt` files in conjunction with `anvi-export-gene-coverage-and-detection` to generate coverage and detection information for each MAG from both HMM profiles. Here we use the list of MAGs (`00_WA-MAGS.txt`) in a `for` loop to produce the files for each MAG.

```bash
for mag in `cat 00_WA-MAGS.txt`
do anvi-export-gene-coverage-and-detection \
                    --profile-db $mag/PROFILE.db \
                    --contigs-db $mag/CONTIGS.db \
                    --genes-of-interest $mag-Archaea_76-gene_ids.txt \
                    --output-file-prefix $mag-Archaea_76

do anvi-export-gene-coverage-and-detection \
                    --profile-db $mag/PROFILE.db \
                    --contigs-db $mag/CONTIGS.db \
                    --genes-of-interest $mag-Bacteria_71-gene_ids.txt \
                    --output-file-prefix $mag-Bacteria_71

done
```

It is worth noting that the same data can be generated by adding the `-init-gene-coverages` flag to `anvi-summarize` on the collection of MAGs. This will generate coverage stats for all genes in a MAG. At that point you would need to parse out the genes of interest from the output files. Story for another time. 

Almost done. It would be nice to add in a few more details for each SCG hit from our MAGs. We can use `anvi-get-sequences-for-hmm-hits` for this task. The output of this function is a fasta file containing detailed deflines. For the record, the deflines contains information on the source HMM profile, e-value score, parent contig id, gene callers id, gene name, gene length, and the gene's start/stop positions. Here we use the `seqinr` package to read the fasta file and then parse out the relevant information.


```bash
anvi-get-sequences-for-hmm-hits --internal-genomes internal-genomes.txt \
                                --hmm-sources Archaea_76 \
                                --output-file 08_MAGS-Archaea_76-sequences.fa \
                                --unique-genes --no-wrap

anvi-get-sequences-for-hmm-hits --internal-genomes internal-genomes.txt 
                                --hmm-sources Bacteria_71 \
                                --output-file 08_MAGS-Bacteria_71-sequences.fa \
                                --unique-genes --no-wrap

```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack files**   
- [08_MAGS-Archaea_76-sequences.fa](files/MAG/08_MAGS-Archaea_76-sequences.fa)  
- [08_MAGS-Bacteria_71-sequences.fa](files/MAG/08_MAGS-Bacteria_71-sequences.fa)
::::

```{r, code_folding=TRUE}
tmp_fa <- seqinr::read.fasta("files/MAG/08_MAGS-Archaea_76-sequences.fa", 
                             as.string = TRUE, whole.header = TRUE)
tmp_fa <- data.frame(seqinr::getName(tmp_fa))
tmp_fa <- dplyr::rename(tmp_fa, X1 = 1)
# COount number of delimiters (|) and add 1 for first column
tmp_ncols <- max(stringr::str_count(tmp_fa$X1, "[|]")) + 1
tmp_colmn <- paste("col", 1:tmp_ncols, sep = "_")

tmp_gene_info <- tidyr::separate(data = tmp_fa, col = X1, sep = "[|]", 
                                 into = tmp_colmn, remove = TRUE)
tmp_gene_info[, c(2,4,6,7)] <- NULL
tmp_gene_info$col_5 <- gsub("^gene_callers_id:hash.*_", "", tmp_gene_info$col_5)
tmp_gene_info$col_3 <- gsub("^e_value:", "", tmp_gene_info$col_3)
tmp_gene_info$col_1 <- gsub("_{3}Archaea_76_{3}.*bin_id:", "XXXXX", tmp_gene_info$col_1)
tmp_gene_info$col_8 <- gsub("^length:", "", tmp_gene_info$col_8)

tmp_gene_info <- tmp_gene_info %>% tidyr::separate(col = col_1, sep = "XXXXX", 
                                 into = c("gene_name", "mag_id"), remove = TRUE)

tmp_gene_info <- tmp_gene_info %>% dplyr::rename(e_value = 3, gene_callers_id = 4, length = 5)  
arch76_gene_hits <- tmp_gene_info
arch76_gene_hits$gene_callers_id <- as.numeric(arch76_gene_hits$gene_callers_id)
rm(list = ls(pattern = "tmp_"))
```

```{r, code_folding=TRUE}
tmp_fa <- seqinr::read.fasta("files/MAG/08_MAGS-Bacteria_71-sequences.fa", 
                             as.string = TRUE, whole.header = TRUE)
tmp_fa <- data.frame(seqinr::getName(tmp_fa))
tmp_fa <- dplyr::rename(tmp_fa, X1 = 1)
# COount number of delimiters (|) and add 1 for first column
tmp_ncols <- max(stringr::str_count(tmp_fa$X1, "[|]")) + 1
tmp_colmn <- paste("col", 1:tmp_ncols, sep = "_")

tmp_gene_info <- tidyr::separate(data = tmp_fa, col = X1, sep = "[|]", 
                                 into = tmp_colmn, remove = TRUE)
tmp_gene_info[, c(2,4,6,7)] <- NULL
tmp_gene_info$col_5 <- gsub("^gene_callers_id:hash.*_", "", tmp_gene_info$col_5)
tmp_gene_info$col_3 <- gsub("^e_value:", "", tmp_gene_info$col_3)
tmp_gene_info$col_1 <- gsub("_{3}Bacteria_71_{3}.*bin_id:", "XXXXX", tmp_gene_info$col_1)
tmp_gene_info$col_8 <- gsub("^length:", "", tmp_gene_info$col_8)

tmp_gene_info <- tmp_gene_info %>% tidyr::separate(col = col_1, sep = "XXXXX", 
                                 into = c("gene_name", "mag_id"), remove = TRUE)

tmp_gene_info <- tmp_gene_info %>% dplyr::rename(e_value = 3, gene_callers_id = 4, length = 5)  
bact71_gene_hits <- tmp_gene_info
bact71_gene_hits$gene_callers_id <- as.numeric(bact71_gene_hits$gene_callers_id)
rm(list = ls(pattern = "tmp_"))
```

```{r, echo=FALSE}
write.table(arch76_gene_hits, "files/MAG/09_MAGS-Archaea_76-details.txt", 
              col.names  = TRUE, row.names = FALSE, sep = "\t", quote = FALSE)
write.table(bact71_gene_hits, "files/MAG/09_MAGS-Bacteria_71-details.txt", 
              col.names  = TRUE, row.names = FALSE, sep = "\t", quote = FALSE)
```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack files**  
- [09_MAGS-Archaea_76-details.txt](files/MAG/09_MAGS-Archaea_76-details.txt)  
- [09_MAGS-Bacteria_71-details.txt](files/MAG/09_MAGS-Bacteria_71-details.txt)
::::

The analysis yielded `r nrow(bact71_gene_hits)` genes from MAGs that had hits to the Bacteria_71 profile. 

Finally, we can generate files for each MAG that contains the **a**) gene callers ID's (these are unique),	**b**) HMM source (`Archaea_76` or `Bacteria_71`),	**c**) gene name,	**d**) Pfam gene ID, and **e**) coverage or detection across samples.

First for `Archaea_76`. 

```{r, eval=FALSE, code_folding=TRUE}
wa_mags <- read_delim("files/MAG/00_WA-MAGS.txt", delim = "\t", col_names = FALSE)
wa_mags <- wa_mags$X1
for (mag in wa_mags) {
  cat("Reading", mag, "gene list")
  tmp_gene_id <- read_delim(paste("files/MAG/Archaea_76/09_HMM_HITS_PER_GENE_CALLS/", 
                                  mag, "-Archaea_76.txt", sep = ""), 
                            delim = "\t", col_names = TRUE)
  tmp_gene_id[,1] <- NULL
  cat("Subsetting", mag, "from SCG detailed hits file. ")
  tmp_subset <- subset(arch76_gene_hits, mag_id == mag)
  cat("Reading", mag, "coverage")
  tmp_coverage <- read_delim(paste("files/MAG/Archaea_76/11_COVERAGE_RAW/", 
                                   mag, "-Archaea_76-GENE-COVERAGES.txt", sep = ""), 
                             delim = "\t", col_names = TRUE)
  cat("Reading", mag, "detection")
  tmp_detection <- read_delim(paste("files/MAG/Archaea_76/11_DETECTION_RAW/", 
                                    mag, "-Archaea_76-GENE-DETECTION.txt", sep = ""), 
                              delim = "\t", col_names = TRUE)
  cat("MAG", mag, "gene file has ", nrow(tmp_gene_id), "entries", "\n")
  cat("MAG", mag, "coverage file has ", nrow(tmp_coverage), "entries", "\n")
  cat("MAG", mag, "detection file has ", nrow(tmp_detection), "entries", "\n")
  cat("MAG", mag, "details file has ", nrow(tmp_subset), "entries", "\n")
  cat("Joining", mag, "gene ID and coverage files")
  tmp_coverage_join <- dplyr::full_join(tmp_gene_id, tmp_coverage, 
                                        by = c("gene_callers_id" = "key")) %>%
                       dplyr::full_join(., tmp_subset, 
                                        by = c("gene_callers_id" = "gene_callers_id", 
                                               "gene_name" = "gene_name"))
  tmp_coverage_join <- tmp_coverage_join %>% dplyr::relocate(c("e_value", "length"), .after = "gene_hmm_id")
  cat("Joining", mag, "gene ID and detection files")
  tmp_detection_join <- dplyr::full_join(tmp_gene_id, tmp_detection, 
                                        by = c("gene_callers_id" = "key")) %>%
                       dplyr::full_join(., tmp_subset, 
                                        by = c("gene_callers_id" = "gene_callers_id", 
                                               "gene_name" = "gene_name"))
  tmp_detection_join <- tmp_detection_join %>% dplyr::relocate(c("e_value", "length"), .after = "gene_hmm_id")

  tmp_coverage_name <- purrr::map_chr(mag, ~ paste0(., "_Archaea_76-coverage.txt"))
  tmp_detection_name <- purrr::map_chr(mag, ~ paste0(., "_Archaea_76-detection.txt"))  
  
  write.table(tmp_coverage_join, paste("files/MAG/Archaea_76/12_COVERAGE/", tmp_coverage_name, sep = ""), 
              col.names  = TRUE, row.names = FALSE, sep = "\t", quote = FALSE)
  
  write.table(tmp_detection_join, paste("files/MAG/Archaea_76/12_DETECTION/", tmp_detection_name, sep = ""), 
              col.names  = TRUE, row.names = FALSE, sep = "\t", quote = FALSE)
  rm(list = ls(pattern = "tmp_"))
}
```

And then for `Bacteria_71`.

```{r, eval=FALSE, code_folding=TRUE}
wa_mags <- read_delim("files/MAG/00_WA-MAGS.txt", delim = "\t", col_names = FALSE)
wa_mags <- wa_mags$X1
for (mag in wa_mags) {
  cat("Reading", mag, "gene list")
  tmp_gene_id <- read_delim(paste("files/MAG/Bacteria_71/09_HMM_HITS_PER_GENE_CALLS/", 
                                  mag, "-Bacteria_71.txt", sep = ""), 
                            delim = "\t", col_names = TRUE)
  tmp_gene_id[,1] <- NULL
  cat("Subsetting", mag, "from SCG detailed hits file. ")
  tmp_subset <- subset(bact71_gene_hits, mag_id == mag)
  cat("Reading", mag, "coverage")
  tmp_coverage <- read_delim(paste("files/MAG/Bacteria_71/11_COVERAGE_RAW/", 
                                   mag, "-Bacteria_71-GENE-COVERAGES.txt", sep = ""), 
                             delim = "\t", col_names = TRUE)
  cat("Reading", mag, "detection")
  tmp_detection <- read_delim(paste("files/MAG/Bacteria_71/11_DETECTION_RAW/", 
                                    mag, "-Bacteria_71-GENE-DETECTION.txt", sep = ""), 
                              delim = "\t", col_names = TRUE)
  cat("MAG", mag, "gene file has ", nrow(tmp_gene_id), "entries", "\n")
  cat("MAG", mag, "coverage file has ", nrow(tmp_coverage), "entries", "\n")
  cat("MAG", mag, "detection file has ", nrow(tmp_detection), "entries", "\n")
  cat("MAG", mag, "details file has ", nrow(tmp_subset), "entries", "\n")
  cat("Joining", mag, "gene ID and coverage files")
  tmp_coverage_join <- dplyr::full_join(tmp_gene_id, tmp_coverage, 
                                        by = c("gene_callers_id" = "key")) %>%
                       dplyr::full_join(., tmp_subset, 
                                        by = c("gene_callers_id" = "gene_callers_id", 
                                               "gene_name" = "gene_name"))
  tmp_coverage_join <- tmp_coverage_join %>% dplyr::relocate(c("e_value", "length"), .after = "gene_hmm_id")
  cat("Joining", mag, "gene ID and detection files")
  tmp_detection_join <- dplyr::full_join(tmp_gene_id, tmp_detection, 
                                        by = c("gene_callers_id" = "key")) %>%
                       dplyr::full_join(., tmp_subset, 
                                        by = c("gene_callers_id" = "gene_callers_id", 
                                               "gene_name" = "gene_name"))
  tmp_detection_join <- tmp_detection_join %>% dplyr::relocate(c("e_value", "length"), .after = "gene_hmm_id")

  tmp_coverage_name <- purrr::map_chr(mag, ~ paste0(., "_Bacteria_71-coverage.txt"))
  tmp_detection_name <- purrr::map_chr(mag, ~ paste0(., "_Bacteria_71-detection.txt"))  
  
  write.table(tmp_coverage_join, paste("files/MAG/Bacteria_71/12_COVERAGE/", tmp_coverage_name, sep = ""), 
              col.names  = TRUE, row.names = FALSE, sep = "\t", quote = FALSE)
  
  write.table(tmp_detection_join, paste("files/MAG/Bacteria_71/12_DETECTION/", tmp_detection_name, sep = ""), 
              col.names  = TRUE, row.names = FALSE, sep = "\t", quote = FALSE)
  rm(list = ls(pattern = "tmp_"))
}
```

```{r, echo=FALSE, eval=FALSE}
zip(zipfile = "files/MAG_WF_DATA.zip", files = "files/MAG/")
```


```{r, echo=FALSE}
objects()
save.image("page_build/index_mag.rdata")
```


# Metagenome Workflow

```{r, message=FALSE, results = 'hide', eval=TRUE, echo=FALSE}
remove(list = ls())
load("page_build/index_mg.rdata")
```


## Description of Data Products

The link below gives access to all data and data products generated in the workflow. This is a 25.7Mb zip file. 

```{r, eval=TRUE, echo=FALSE}
download_link(
  link = "https://github.com/istmobiome/scg/raw/main/files/MG_WF_DATA.zip",
  button_label = "Download the full data pack here",
  button_type = "success",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
```


There are a number of data products generated in this workflow. Below is a description of each product  and links to download the data. Some of this information is redundant, others may not be useful, but all are included here for posterity. 

First, a description of individual tables. 

::: l-body-outset

| **file name**                                                                                 | **description**                                    |
|-----------------------------------------------------------------------------------------------|----------------------------------------------------|
| [00_SCG_TAXONOMY_GENES.txt](files/MG/00_SCG_TAXONOMY_GENES.txt)                               | list of GTDB SCG.                                  |
| [01_WA-Archaea_76-sequences.fa](files/MG/01_WA-Archaea_76-sequences.fa)                       | fasta file of all Archaea_76 SCG hits.             |
| [01_WA-Bacteria_71-sequences.fa](files/MG/01_WA-Bacteria_71-sequences.fa)                     | fasta file of all Bacteria_71 SCG hits.            |
| [02_WA-Archaea_76-HITS.txt](files/MG/02_WA-Archaea_76-HITS.txt)                               | table of all Archaea_76 SCG hits.                  |
| [02_WA-Bacteria_71-HITS.txt](files/MG/02_WA-Bacteria_71-HITS.txt)                             | table of all Bacteria_71 SCG hits.                 |
| [03_WA-Archaea_76-gene_ids.txt](files/MG/03_WA-Archaea_76-gene_ids.txt)                       | gene ids of all Archaea_76 SCG hits.               |
| [03_WA-Bacteria_71-gene_ids.txt](files/MG/03_WA-Bacteria_71-gene_ids.txt)                     | gene ids of all Bacteria_71 SCG hits.              |
| [04_WA-Archaea_76-RAW-GENE-COVERAGES.txt](files/MG/04_WA-Archaea_76-RAW-GENE-COVERAGES.txt)   | raw coverage data for Archaea_76 SCG hits.         |
| [04_WA-Archaea_76-RAW-GENE-DETECTION.txt](files/MG/04_WA-Archaea_76-RAW-GENE-DETECTION.txt)   | raw detection data for Archaea_76 SCG hits.        |
| [04_WA-Bacteria_71-RAW-GENE-COVERAGES.txt](files/MG/04_WA-Bacteria_71-RAW-GENE-COVERAGES.txt) | raw coverage data for Bacteria_71 SCG hits.        |
| [04_WA-Bacteria_71-RAW-GENE-DETECTION.txt](files/MG/04_WA-Bacteria_71-RAW-GENE-DETECTION.txt) | raw detection data for Bacteria_71 SCG hits.       |
| [05_WA-Archaea_76-GENE-COVERAGES.txt](files/MG/05_WA-Archaea_76-GENE-COVERAGES.txt)           | **final coverage data for Archaea_76**.            |
| [05_WA-Archaea_76-GENE-DETECTION.txt](files/MG/05_WA-Archaea_76-GENE-DETECTION.txt)           | **final detection data for Archaea_76**.           |
| [05_WA-Bacteria_71-GENE-COVERAGES.txt](files/MG/05_WA-Bacteria_71-GENE-COVERAGES.txt)         | **final coverage data for Bacteria_71**.           |
| [05_WA-Bacteria_71-GENE-DETECTION.txt](files/MG/05_WA-Bacteria_71-GENE-DETECTION.txt)         | **final detection data for Bacteria_71**.          |
| 06_SCG_TAXONOMY/                                                                              | taxonomy files for each GTDB SCG.                  |
| [07_SCG_TAXONOMY.txt](files/MG/07_SCG_TAXONOMY.txt)                                           | **combined GTDB taxonomy for all genes**           |
:::


## Generate SCG lists

On my first pass through this workflow I noticed that a few genes had hits to several HMM profile genes. So I needed to remove duplicate hits. The best way I found was to use `anvi-get-sequences-for-hmm-hits` with the flag `--unique-genes`.  From the help menu of this function, anvi'o tells us:

```
--unique-genes    An HMM source may contain multiple models that can hit
                  the same gene in a given bin or genome. Using this
                  flag, you can ask anvi'o to go through all genes,
                  identify those with multiple hits and report only the
                  most significant hit for each unique gene. (default
                  False)
```

Excellent. This seemed promising. The output of this function is a fasta file containing detailed deflines. 

```bash
anvi-get-sequences-for-hmm-hits --contigs-db 03_CONTIGS/WA-contigs.db \
                                --hmm-sources Archaea_76 \
                                --output-file 01_WA-Archaea_76-sequences.fa  \
                                --unique-genes --no-wrap
                                
anvi-get-sequences-for-hmm-hits --contigs-db 03_CONTIGS/WA-contigs.db \
                                --hmm-sources Bacteria_71 \
                                --output-file 01_WA-Bacteria_71-sequences.fa  \
                                --unique-genes --no-wrap

```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack files**   
- [01_WA-Archaea_76-sequences.fa](files/MG/01_WA-Archaea_76-sequences.fa)  
- [01_WA-Bacteria_71-sequences.fa](files/MG/01_WA-Bacteria_71-sequences.fa)
::::

For the record, the deflines contain information on the source HMM profile, e-value score, parent contig id, gene callers id, gene name, gene length, and the gene's start/stop positions. Here we use the `seqinr` package to read the fasta file and then I parse out the relevant information.

First, I start with the Archaea_76 profile. 

```{r blah, code_folding=TRUE}
tmp_fa <- seqinr::read.fasta("files/MG/01_WA-Archaea_76-sequences.fa", 
                             as.string = TRUE, whole.header = TRUE)
tmp_fa <- data.frame(seqinr::getName(tmp_fa))
tmp_fa <- dplyr::rename(tmp_fa, X1 = 1)
# COount number of delimiters (|) and add 1 for first column
tmp_ncols <- max(stringr::str_count(tmp_fa$X1, "[|]")) + 1
tmp_colmn <- paste("col", 1:tmp_ncols, sep = "_")

tmp_gene_info <- tidyr::separate(data = tmp_fa, col = X1, sep = "[|]", 
                                 into = tmp_colmn, remove = TRUE)
tmp_gene_info[, c(2,4,6,7)] <- NULL
tmp_gene_info$col_5 <- gsub("^gene_callers_id:", "", tmp_gene_info$col_5)
tmp_gene_info$col_3 <- gsub("^e_value:", "", tmp_gene_info$col_3)
tmp_gene_info$col_1 <- gsub("_{3}.*", "", tmp_gene_info$col_1)
tmp_gene_info$col_8 <- gsub("^length:", "", tmp_gene_info$col_8)
tmp_gene_info <- tmp_gene_info %>% dplyr::rename(gene_name = 1, e_value = 2, gene_callers_id = 3, length = 4)  
arch76_gene_hits <- tmp_gene_info
arch76_gene_hits$gene_callers_id <- as.numeric(arch76_gene_hits$gene_callers_id)
rm(list = ls(pattern = "tmp_"))
```

The analysis yielded `r nrow(arch76_gene_hits)` genes that had hits to the Archaea_76 profile. Now for the Bacteria_71 profile. 

```{r, code_folding=TRUE}
tmp_fa <- seqinr::read.fasta("files/MG/01_WA-Bacteria_71-sequences.fa", 
                             as.string = TRUE, whole.header = TRUE)
tmp_fa <- data.frame(seqinr::getName(tmp_fa))
tmp_fa <- dplyr::rename(tmp_fa, X1 = 1)
# COount number of delimiters (|) and add 1 for first column
tmp_ncols <- max(stringr::str_count(tmp_fa$X1, "[|]")) + 1
tmp_colmn <- paste("col", 1:tmp_ncols, sep = "_")

tmp_gene_info <- tidyr::separate(data = tmp_fa, col = X1, sep = "[|]", 
                                 into = tmp_colmn, remove = TRUE)
tmp_gene_info[, c(2,4,6,7)] <- NULL
tmp_gene_info$col_5 <- gsub("^gene_callers_id:", "", tmp_gene_info$col_5)
tmp_gene_info$col_3 <- gsub("^e_value:", "", tmp_gene_info$col_3)
tmp_gene_info$col_1 <- gsub("_{3}.*", "", tmp_gene_info$col_1)
tmp_gene_info$col_8 <- gsub("^length:", "", tmp_gene_info$col_8)
tmp_gene_info <- tmp_gene_info %>% dplyr::rename(gene_name = 1, e_value = 2, gene_callers_id = 3, length = 4)  
bact71_gene_hits <- tmp_gene_info
bact71_gene_hits$gene_callers_id <- as.numeric(bact71_gene_hits$gene_callers_id)
rm(list = ls(pattern = "tmp_"))
```

The analysis yielded `r nrow(bact71_gene_hits)` genes that had hits to the Bacteria_71 profile. So for each profile I now had a file containing the gene name, e-value, and unique gene caller id. Next, I run `anvi-script-get-hmm-hits-per-gene-call`. This function yields basically the same data except it has the duplicate hits and reports the Pfam ID for each gene in the profile. I not only want the Pfam ID but I also want to compare the results as a sanity check and access the number of duplicate hits. 

```bash
anvi-script-get-hmm-hits-per-gene-call --contigs-db 03_CONTIGS/WA-contigs.db \
                                       --hmm-source Archaea_76 \
                                       --output-file 02_WA-Archaea_76-HITS.txt

anvi-script-get-hmm-hits-per-gene-call --contigs-db 03_CONTIGS/WA-contigs.db \
                                       --hmm-source Bacteria_71 \
                                       --output-file 02_WA-Bacteria_71-HITS.txt
```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack files**   
- [02_WA-Archaea_76-HITS.txt](files/MG/02_WA-Archaea_76-HITS.txt)  
- [02_WA-Bacteria_71-HITS.txt](files/MG/02_WA-Bacteria_71-HITS.txt)
::::

Now I can join the two tables by `gene_callers_id` and `gene_name`. 

```{r, code_folding=TRUE, eval=TRUE}
tmp_hits <- read_delim("files/MG/02_WA-Archaea_76-HITS.txt", delim = "\t")
```

Looks like there were only `r nrow(tmp_hits) - nrow(arch76_gene_hits)` duplicate hits against the `Archaea_76` profile. 

```{r, code_folding=TRUE}
tmp_tab <- dplyr::left_join(arch76_gene_hits, tmp_hits, by = c("gene_callers_id", "gene_name"))
tmp_tab <- tmp_tab %>% dplyr::relocate("e_value", .after = "gene_hmm_id") 
tmp_tab <- tmp_tab %>% dplyr::relocate("unique_entry_id", .before = "gene_name") 
tmp_tab <- tmp_tab %>% dplyr::relocate("source", .after = "gene_callers_id") 
arch76_gene_info <- tmp_tab
rm(list = ls(pattern = "tmp_"))
```

```{r, code_folding=TRUE, eval=TRUE}
tmp_hits <- read_delim("files/MG/02_WA-Bacteria_71-HITS.txt", delim = "\t")
```

And there were  `r nrow(tmp_hits) - nrow(bact71_gene_hits)` duplicate hits against the `Bacteria_71` profile. 

```{r, code_folding=TRUE}
tmp_tab <- dplyr::left_join(bact71_gene_hits, tmp_hits, by = c("gene_callers_id", "gene_name"))
tmp_tab <- tmp_tab %>% dplyr::relocate("e_value", .after = "gene_hmm_id") 
tmp_tab <- tmp_tab %>% dplyr::relocate("unique_entry_id", .before = "gene_name") 
tmp_tab <- tmp_tab %>% dplyr::relocate("source", .after = "gene_callers_id") 
bact71_gene_info <- tmp_tab
rm(list = ls(pattern = "tmp_"))
```

## SCG Coverage 

And now we can calculate coverage and detection for each SCG in our analysis. To accomplish this task, we first need to parse out the `gene_callers_id` column, remove the header, and save the file. 

```{r, echo=FALSE}
write.table(data.frame(arch76_gene_info[,3]), "files/MG/03_WA-Archaea_76-gene_ids.txt", 
            quote = FALSE, sep = "\t", col.names = FALSE, row.names = FALSE)
write.table(data.frame(bact71_gene_info[,3]), "files/MG/03_WA-Bacteria_71-gene_ids.txt", 
            quote = FALSE, sep = "\t", col.names = FALSE, row.names = FALSE)
```

:::: {.infobox }
<i class="fas fa-file"></i> **Data pack files**   
- [03_WA-Archaea_76-gene_ids.txt](files/MG/03_WA-Archaea_76-gene_ids.txt)  
- [03_WA-Bacteria_71-gene_ids.txt](files/MG/03_WA-Bacteria_71-gene_ids.txt)
::::

Then run `anvi-export-gene-coverage-and-detection`. 

```bash
anvi-export-gene-coverage-and-detection --profile-db 06_MERGED/WA/PROFILE.db \
                                        --contigs-db 03_CONTIGS/WA-contigs.db \
                                        --genes-of-interest WA-Archaea_76-gene_ids.txt \
                                        --output-file-prefix 04_WA-Archaea_76-RAW

anvi-export-gene-coverage-and-detection --profile-db 06_MERGED/WA/PROFILE.db \
                                        --contigs-db 03_CONTIGS/WA-contigs.db \
                                        --genes-of-interest WA-Bacteria_71-gene_ids.txt \
                                        --output-file-prefix 04_WA-Bacteria_71-RAW
```

```{r, echo=FALSE}
arch76_cov <- read_delim("files/MG/04_WA-Archaea_76-RAW-GENE-COVERAGES.txt", delim = "\t")
arch76_det <- read_delim("files/MG/04_WA-Archaea_76-RAW-GENE-DETECTION.txt", delim = "\t")

bact71_cov <- read_delim("files/MG/04_WA-Bacteria_71-RAW-GENE-COVERAGES.txt", delim = "\t")
bact71_det <- read_delim("files/MG/04_WA-Bacteria_71-RAW-GENE-DETECTION.txt", delim = "\t")
```


:::: {.infobox }
<i class="fas fa-file"></i> **Data pack files**  
- [04_WA-Archaea_76-RAW-GENE-COVERAGES.txt](files/MG/04_WA-Archaea_76-RAW-GENE-COVERAGES.txt)     
- [04_WA-Archaea_76-RAW-GENE-DETECTION.txt](files/MG/04_WA-Archaea_76-RAW-GENE-DETECTION.txt)  
- [04_WA-Bacteria_71-RAW-GENE-COVERAGES.txt](files/MG/04_WA-Bacteria_71-RAW-GENE-COVERAGES.txt)  
- [04_WA-Bacteria_71-RAW-GENE-DETECTION.txt](files/MG/04_WA-Bacteria_71-RAW-GENE-DETECTION.txt)
::::

Once we run `anvi-export-gene-coverage-and-detection` for both HMM profiles we can combine these data with all of the other SCG stats generated above. 

```{r, code_folding=TRUE}
tmp_tab <- dplyr::full_join(arch76_gene_info, arch76_cov, by = c("gene_callers_id" = "key"))
tmp_tab <- tmp_tab %>% dplyr::relocate("gene_name", .after = "source")
tmp_tab$unique_entry_id <- NULL
arch76_cov <- tmp_tab
rm(list = ls(pattern = "tmp_"))

tmp_tab <- dplyr::full_join(arch76_gene_info, arch76_det, by = c("gene_callers_id" = "key"))
tmp_tab <- tmp_tab %>% dplyr::relocate("gene_name", .after = "source")
tmp_tab$unique_entry_id <- NULL
arch76_det <- tmp_tab
rm(list = ls(pattern = "tmp_"))

tmp_tab <- dplyr::full_join(bact71_gene_info, bact71_cov, by = c("gene_callers_id" = "key"))
tmp_tab <- tmp_tab %>% dplyr::relocate("gene_name", .after = "source")
tmp_tab$unique_entry_id <- NULL
bact71_cov <- tmp_tab
rm(list = ls(pattern = "tmp_"))

tmp_tab <- dplyr::full_join(bact71_gene_info, bact71_det, by = c("gene_callers_id" = "key"))
tmp_tab <- tmp_tab %>% dplyr::relocate("gene_name", .after = "source")
tmp_tab$unique_entry_id <- NULL
bact71_det <- tmp_tab
rm(list = ls(pattern = "tmp_"))
```

```{r, echo=FALSE}
write.table(arch76_cov, "files/MG/05_WA-Archaea_76-GENE-COVERAGES.txt", 
            quote = FALSE, sep = "\t", col.names = TRUE, row.names = FALSE)
write.table(arch76_det, "files/MG/05_WA-Archaea_76-GENE-DETECTION.txt", 
            quote = FALSE, sep = "\t", col.names = TRUE, row.names = FALSE)

write.table(bact71_cov, "files/MG/05_WA-Bacteria_71-GENE-COVERAGES.txt", 
            quote = FALSE, sep = "\t", col.names = TRUE, row.names = FALSE)
write.table(bact71_det, "files/MG/05_WA-Bacteria_71-GENE-DETECTION.txt", 
            quote = FALSE, sep = "\t", col.names = TRUE, row.names = FALSE)
```


:::: {.infobox }
<i class="fas fa-file"></i> **Data pack files**  
- [05_WA-Archaea_76-GENE-COVERAGES.txt](files/MG/05_WA-Archaea_76-GENE-COVERAGES.txt)     
- [05_WA-Archaea_76-GENE-DETECTION.txt](files/MG/05_WA-Archaea_76-GENE-DETECTION.txt)  
- [05_WA-Bacteria_71-GENE-COVERAGES.txt](files/MG/05_WA-Bacteria_71-GENE-COVERAGES.txt)     
- [05_WA-Bacteria_71-GENE-DETECTION.txt](files/MG/05_WA-Bacteria_71-GENE-DETECTION.txt)  
::::

## GTDB SCG Taxonomy 

Alright. Now we want the taxonomic assignment for each of the 22 SCG used by the GTDB. For this we use  `anvi-estimate-scg-taxonomy` in `--metagenome-mode`. When running in metagenome mode, anvi'o *automatically chooses the most frequent single-copy core gene* to estimate the taxonomic composition within a contigs database. However, we want taxonomic assignment for ALL genes. For this, we generate a list of the GTDB SCG and use a for loop that will run through each SCG and calculate taxonomy for all hits in our database. So this command will produce 22 files. 

```bash
for gene in `SCG_TAXONOMY_GENES.txt`
do anvi-estimate-scg-taxonomy  --contigs-db 03_CONTIGS/WA-contigs.db  \
                               --output-file 06_SCG_TAXONOMY/WA-$gene-TAXONOMY.txt \
                               --metagenome-mode \
                               --scg-name-for-metagenome-mode $gene
done

```

:::: {.infobox }
<i class="fas fa-file"></i> **Data directory**  06_SCG_TAXONOMY/
::::

Great. Here we use a for loop to **a**) read in each taxonomy file, **b**) do a little reformatting, and **c**) combine all data in one file.  

```{r, code_folding=TRUE}
scg_genes <- read_delim("files/MG/00_SCG_TAXONOMY_GENES.txt", delim = "\t", col_names = FALSE)

scg_tax <- c()
for (gene in scg_genes$X1) {
  tmp_tax <- read_delim(paste("files/MG/06_SCG_TAXONOMY/", "WA-", gene, "-TAXONOMY.txt", sep = ""), 
                        delim = "\t")
  tmp_tax$scg_name <- gsub("^WA_", "", tmp_tax$scg_name)
  tmp_tax$gene_id <- tmp_tax$scg_name
  tmp_tax <- tmp_tax %>% dplyr::relocate("gene_id", .after = "scg_name")
  tmp_tax$scg_name <- gsub("_[0-9]*$", "", tmp_tax$scg_name)
  tmp_tax$gene_id <- gsub(paste(gene, "_", sep = ""), "", tmp_tax$gene_id)
  scg_tax <- rbind(scg_tax, tmp_tax)
  
  rm(list = ls(pattern = "tmp_"))
}
subset(scg_tax, duplicated(gene_id))
write.table(scg_tax, "files/MG/07_SCG_TAXONOMY.txt", 
            quote = FALSE, sep = "\t", col.names = TRUE, row.names = FALSE)
```


:::: {.infobox }
<i class="fas fa-file"></i> **Data pack file**  [07_SCG_TAXONOMY.txt](files/MG/07_SCG_TAXONOMY.txt)     
::::

<details markdown="1">
<summary><strong>Click here</strong> for a breakdown of total hits by GTDB SCG..</summary>

```{r, echo=FALSE}
scg_count <- scg_tax %>% dplyr::count(scg_name)
```

</br>

| **scg_name**   | **count**                                                                   |
|----------------|-----------------------------------------------------------------------------|
| Ribosomal_L1   | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L1",][,   2])`   |
| Ribosomal_L13  | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L13",][, 2])`    |
| Ribosomal_L16  | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L16",][, 2])`    |
| Ribosomal_L17  | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L17",][, 2])`    |
| Ribosomal_L2   | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L2",][,   2])`   |
| Ribosomal_L20  | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L20",][, 2])`    |
| Ribosomal_L21p | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L21p",][, 2])`   |
| Ribosomal_L22  | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L22",][, 2])`    |
| Ribosomal_L27A | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L27A",][, 2])`   |
| Ribosomal_L3   | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L3",][,   2])`   |
| Ribosomal_L4   | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L4",][,   2])`   |
| Ribosomal_L6   | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L6",][,   2])`   |
| Ribosomal_L9_C | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_L9_C",][, 2])`   |
| Ribosomal_S11  | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_S11",][, 2])`    |
| Ribosomal_S2   | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_S2",][,   2])`   |
| Ribosomal_S20p | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_S20p",][, 2])`   |
| Ribosomal_S3_C | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_S3_C",][, 2])`   |
| Ribosomal_S6   | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_S6",][,   2])`   |
| Ribosomal_S7   | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_S7",][,   2])`   |
| Ribosomal_S8   | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_S8",][,   2])`   |
| Ribosomal_S9   | `r as.character(scg_count[scg_count$scg_name == "Ribosomal_S9",][,   2])`   |
| ribosomal_L24  | `r as.character(scg_count[scg_count$scg_name == "ribosomal_L24",][, 2])`    |

</details>

```{r, echo=FALSE, eval=FALSE}
zip(zipfile = "files/MG_WF_DATA.zip", files = "files/MG/")
```

```{r, message=FALSE, results = 'hide', eval=FALSE, echo=FALSE}
save.image("page_build/index_mg.rdata")
```

```{r, message=FALSE, results = 'hide', eval=TRUE, echo=FALSE}
remove(list = ls())
```

That's all for now. See you soon. 





